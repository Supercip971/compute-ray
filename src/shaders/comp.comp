#version 450
#extension GL_ARB_separate_shader_objects : enable

#define M_PI 3.1415926535897932384626433832795

#define WORKGROUP_SIZE 16
layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Pixel
{
    vec4 value;
};

layout(std140, binding = 0) buffer buf
{
    Pixel image[];
};

layout(binding = 1) uniform UniformBufferObject
{
    float width;
    float height;
    uint t;
}
ubo;

uint width = uint(ubo.width);
uint height = uint(ubo.height);
uint half_height = height / 2;

uint window_size = 16;
uint half_window_size = window_size / 2;

float W = 1.0;
float ALPHA = 0.022;
float K = 0.05;

// https://www.complexity-explorables.org/explorables/spin-wheels/

struct Ray
{
    vec3 origin;
    vec3 direction;
};
struct RandomResult
{
    uvec4 state;
    float value;
};

uint TausStep(uint z, int S1, int S2, int S3, uint M)
{
    uint b = (((z << S1) ^ z) >> S2);
    return (((z & M) << S3) ^ b);
}

uint LCGStep(uint z, uint A, uint C)
{
    return (A * z + C);
}

RandomResult random_impl(uvec4 state)
{
    state.x = TausStep(state.x, 13, 19, 12, 4294967294);
    state.y = TausStep(state.y, 2, 25, 4, 4294967288);
    state.z = TausStep(state.z, 3, 11, 17, 4294967280);
    state.w = LCGStep(state.w, 1664525, 1013904223);

    RandomResult result;
    result.state = state;
    result.value = 2.3283064365387e-10 * (state.x ^ state.y ^ state.z ^ state.w);

    return result;
}

uvec4 seed;
bool loaded = false;
float random()
{
    if (!loaded)
    {
        seed.x = gl_GlobalInvocationID.x + 128;
        seed.y = gl_GlobalInvocationID.y + 128;
        seed.z = uint(ubo.t + 128);
        seed.w = (uint(ubo.width * ubo.height) ^ ubo.t) + 128;
        loaded = true;
    }

    RandomResult r = random_impl(seed);
    seed = r.state;
    return r.value;
}
vec3 ray_at(Ray r, float v)
{
    return r.origin + r.direction * v;
}
float vec_len(vec3 v)
{
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}
float vec_dot(vec3 r, vec3 l)
{
    return r.x * l.x + r.y * l.y + r.z * l.z;
}
vec3 vec_unit(vec3 v)
{
    return v / vec_len(v);
}
bool hit_sphere(vec3 center, float radius, Ray r)
{
    vec3 oc = r.origin - center;
    float a = vec_dot(r.direction, r.direction);
    float b = 2.0 * vec_dot(oc, r.direction);
    float c = vec_dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4 * a * c;
    return (discriminant > 0);
}
vec4 ray_color(Ray r, float x, float y)
{
    if (hit_sphere(vec3(0, 0, -1), 0.5, r))
    {
        return vec4(random(), random(), random(), 1.0);
    }
    vec3 unit_direction = vec_unit(r.direction);
    float t = (unit_direction.y + 1.0f) * 0.5f;

    return (1.0 - t) * vec4(1.0) + t * vec4(0.5, 0.7, 1.0, 1.0);
}

void main()
{
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    float aspect_ratio = 16.0 / 9.0;
    uint image_width = width;
    uint image_height = uint(width / aspect_ratio);

    // Camera

    float viewport_height = 2.0;
    float viewport_width = aspect_ratio * viewport_height;
    float focal_length = 1.0;

    vec3 origin = vec3(0, 0, 0);
    vec3 horizontal = vec3(viewport_width, 0, 0);
    vec3 vertical = vec3(0, viewport_height, 0);
    vec3 lower_left_corner = origin - horizontal / 2 - vertical / 2 - vec3(0, 0, focal_length);

    if (x + window_size > width || y + window_size > height)
    {
        return;
    }

    float count = 0;
    float accum = 0;

    uint pos = width * y + x;

    for (int i = 0; i < window_size; i++)
    {
        for (int j = 0; j < window_size; j++)
        {
            vec4 color = vec4(0.0, 0.0, 0.0, 0.0);

            float u = abs((float(i + x) + random()) / float(width - 1));
            float v = abs((float(j + y) + random()) / float(height - 1));

            Ray r;
            r.origin = origin;
            r.direction = lower_left_corner + u * horizontal + v * vertical - origin;
            color += ray_color(r, u, v);
            uint pos2 = width * ((height - (y + j)) + 1) + (x + i);

            if (ubo.t == 0)
            {

                image[pos2].value = color;
            }
            else
            {
                image[pos2].value = ((image[pos2].value * (ubo.t)) + color) / (ubo.t + 1);
            }
        }
    }
}