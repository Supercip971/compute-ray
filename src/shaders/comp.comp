#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_spirv_intrinsics : enable
#extension GL_GOOGLE_include_directive : enable

#define M_PI 3.1415926535897932384626433832795

#define WORKGROUP_SIZE 30
layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Pixel
{
    vec4 value;
};

layout(std140, binding = 0) buffer buf
{
    Pixel image[];
};

layout(std140, binding = 1) uniform UniformBufferObject
{
    float width;
    float height;
    uint t;
    vec4 camera_pos;

    vec4 camera_target;
    vec4 camera_up;
}
ubo;

#include "hittable/hittable.comp"
#include "hittable/meshes.comp"
#include "utils/camera.comp"
#include "utils/random.comp"
#include "utils/ray.comp"
#include "utils/vec.comp"

uint window_sizex = int(ubo.width) / WORKGROUP_SIZE;
uint window_sizey = int(ubo.height) / WORKGROUP_SIZE;

void main()
{
    uint x = gl_GlobalInvocationID.x * window_sizex;
    uint y = gl_GlobalInvocationID.y * window_sizey;

    camera cam = camera_init(ubo.camera_pos.xyz, vec3(ubo.camera_target.xyz), vec3(0, 1, 0));
    if (x + window_sizex > ubo.width || y + window_sizey > ubo.height)
    {
        return;
    }

    uint pos = uint(ubo.width) * y + x;

    for (int i = 0; i < window_sizex; i++)
    {
        for (int j = 0; j < window_sizey; j++)
        {
            vec4 color = vec4(0.0, 0.0, 0.0, 0.0);

            float u = abs((float(i + x) + random()) / (ubo.width - 1));
            float v = abs((float(j + y) + random()) / (ubo.height - 1));

            Ray r;
            r.origin = cam.origin;
            r.direction = cam.llc + u * cam.horizontal + v * cam.vertical - cam.origin;
            color += ray_color(r, u, v);
            uint pos2 = uint(ubo.width) * ((uint(ubo.height) - (y + j)) + 1) + (x + i);

            if (ubo.t == 0)
            {
                image[pos2].value = color;
            }
            else
            {
                image[pos2].value = ((image[pos2].value * (ubo.t)) + color) / (ubo.t + 1);
            }
        }
    }
}