#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_spirv_intrinsics : enable

#define M_PI 3.1415926535897932384626433832795

#define WORKGROUP_SIZE 32
layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Pixel
{
    vec4 value;
};

layout(std140, binding = 0) buffer buf
{
    Pixel image[];
};

layout(std140, binding = 1) uniform UniformBufferObject
{
    float width;
    float height;
    uint t;
    vec4 camera_pos;

    vec4 camera_target;
    vec4 camera_up;
}
ubo;

uint width = uint(ubo.width);
uint height = uint(ubo.height);
uint half_height = height / 2;

uint window_size = 16;
uint half_window_size = window_size / 2;

float W = 1.0;
float ALPHA = 0.022;
float K = 0.05;

// https://www.complexity-explorables.org/explorables/spin-wheels/

struct Ray
{
    vec3 origin;
    vec3 direction;
};
struct RandomResult
{
    uvec4 state;
    float value;
};

uint TausStep(uint z, int S1, int S2, int S3, uint M)
{
    uint b = (((z << S1) ^ z) >> S2);
    return (((z & M) << S3) ^ b);
}

uint LCGStep(uint z, uint A, uint C)
{
    return (A * z + C);
}

RandomResult random_impl(uvec4 state)
{
    state.x = TausStep(state.x, 13, 19, 12, 4294967294);
    state.y = TausStep(state.y, 2, 25, 4, 4294967288);
    state.z = TausStep(state.z, 3, 11, 17, 4294967280);
    state.w = LCGStep(state.w, 1664525, 1013904223);

    RandomResult result;
    result.state = state;
    result.value = 2.3283064365387e-10 * (state.x ^ state.y ^ state.z ^ state.w);

    return result;
}

uvec4 seed;
bool loaded = false;
float random()
{
    if (!loaded)
    {
        seed.x = gl_GlobalInvocationID.x + 128;
        seed.y = gl_GlobalInvocationID.y + 128;
        seed.z = uint(ubo.t + 128);
        seed.w = (uint(ubo.width * ubo.height) ^ ubo.t) + 128;
        loaded = true;
    }

    RandomResult r = random_impl(seed);
    seed = r.state;
    return r.value;
}
vec3 ray_at(Ray r, float v)
{
    return r.origin + r.direction * v;
}
float vec_len(vec3 v)
{
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}
float vec_dot(vec3 r, vec3 l)
{
    return r.x * l.x + r.y * l.y + r.z * l.z;
}
vec3 vec_unit(vec3 v)
{
    return v / vec_len(v);
}
float hit_sphere(vec3 center, float radius, Ray r)
{
    vec3 oc = r.origin - center;
    float a = vec_dot(r.direction, r.direction);
    float b = 2.0 * vec_dot(oc, r.direction);
    float c = vec_dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant < 0)
    {
        return -1.0;
    }
    else
    {
        return (-b - sqrt(discriminant)) / (2.0 * a);
    }
}

vec4 ray_color(Ray r, float x, float y)
{
    float v = (hit_sphere(vec3(0, 0, -1), 0.5, r));

    if (v > 0)
    {
        vec3 n = vec_unit(ray_at(r, v) - vec3(0, 0, -1));
        return vec4(0.5 * (vec3(n.x + 1, n.y + 1, n.z + 1)), 1);
    }

    vec3 unit_direction = vec_unit(r.direction);
    float t = (unit_direction.y + 1.0f) * 0.5f;

    return (1.0 - t) * vec4(1.0) + t * vec4(0.5, 0.7, 1.0, 1.0);
}

struct camera
{
    vec3 origin;
    vec3 llc;
    vec3 horizontal;
    vec3 vertical;
};

camera camera_init(vec3 pos, vec3 to, vec3 up)
{

    float vt = tan(1.5708 / 2.f);
    float he = 2.f * vt;
    float wi = he * (16.f / 9.f);

    vec3 w = normalize(pos - to);
    vec3 u = normalize(cross(up, w));
    vec3 v = cross(w, u);
    camera cam;
    cam.origin = pos;
    cam.horizontal = u * wi;

    cam.vertical = v * he;
    cam.llc = pos - (cam.horizontal / 2) - (cam.vertical / 2) - w;
    return cam;
}

void main()
{
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    // Camera

    /*vec3 origin = vec3(sin(ubo.t / 60.f), 0, 0);
    vec3 horizontal = vec3(viewport_width, 0, 0);
    vec3 vertical = vec3(0, viewport_height, 0);
    vec3 lower_left_corner = origin - horizontal / 2 - vertical / 2 - vec3(0, 0, focal_length);
    */

    camera cam = camera_init(ubo.camera_pos.xyz, vec3(ubo.camera_target.xyz), vec3(0, 1, 0));
    if (x + window_size > width || y + window_size > height)
    {
        return;
    }

    float count = 0;
    float accum = 0;

    uint pos = width * y + x;

    for (int i = 0; i < window_size; i++)
    {
        for (int j = 0; j < window_size; j++)
        {
            vec4 color = vec4(0.0, 0.0, 0.0, 0.0);

            float u = abs((float(i + x) + random()) / float(width - 1));
            float v = abs((float(j + y) + random()) / float(height - 1));

            Ray r;
            r.origin = cam.origin;
            r.direction = cam.llc + u * cam.horizontal + v * cam.vertical - cam.origin;
            color += ray_color(r, u, v);
            uint pos2 = width * ((height - (y + j)) + 1) + (x + i);

            if (ubo.t == 0)
            {

                image[pos2].value = color;
            }
            else
            {
                image[pos2].value = ((image[pos2].value * (ubo.t)) + color) / (ubo.t + 1);
            }
        }
    }
}